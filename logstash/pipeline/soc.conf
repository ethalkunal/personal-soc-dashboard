input {
  file {
    path => "/usr/share/logstash/synthetic_logs.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => plain
  }
}

filter {
  # Grok to parse the standard syslog line format
  grok {
    match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:hostname} %{PROG:process_name}(?:\[%{NUMBER:pid}\])?: %{GREEDYDATA:log_message}" }
  }

  # Use the timestamp from the log entry as the event's official timestamp
  date {
    match => [ "syslog_timestamp", "MMM dd HH:mm:ss", "MMM  d HH:mm:ss" ]
    target => "@timestamp"
  }

  # Your original logic for tagging events (with a typo fix)
  # NOTE: Your log file says "Successfull login" (2 L's)
  if [log_message] =~ /Failed login/ {
    mutate { add_tag => ["failed_login"] }
  }
  if [log_message] =~ /Successfull login/ {
    mutate { add_tag => ["successful_login"] }
  }
  if [log_message] =~ /User login successful/ {
    mutate { add_tag => ["successful_login"] }
  }
  if [log_message] =~ /Alert/ {
    mutate { add_tag => ["alert"] }
  }

  # Optional: Clean up by removing the original raw message if parsing is successful
  if "_grokparsefailure" not in [tags] {
    mutate {
      remove_field => ["message", "syslog_timestamp"]
    }
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "logstash-%{+YYYY.MM.dd}"
    ecs_compatibility => "v8"
  }
  stdout { codec => rubydebug }
}
